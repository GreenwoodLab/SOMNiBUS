% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BSMethSim.R
\name{BSMethSim}
\alias{BSMethSim}
\title{Simulate Bisulfite sequencing data from specified smooth covariate effects}
\usage{
BSMethSim(
  n,
  posit,
  theta.0,
  beta,
  random.eff = F,
  mu.e = 0,
  sigma.ee = 1,
  p0 = 0.003,
  p1 = 0.9,
  X,
  Z,
  binom.link = "logit"
)
}
\arguments{
\item{n}{sample size}

\item{posit}{genomic position; a numeric vector of size \code{p} (the number of CpG sites in the considered region).}

\item{theta.0}{a functional parameter for the intercept of the GAMM model; a numeric vector of size \code{p}.}

\item{beta}{a functional parameter for the slope of cell type composition. a numeric vector of size \code{p}}

\item{random.eff}{indicate whether adding the subject-specific random effect term \code{e}.}

\item{mu.e}{the mean of the random effect; a single number.}

\item{sigma.ee}{variance of the random effect; a single positive number.}

\item{p0}{the probability of observing a methylated read when the underlying true status is unmethylated.}

\item{p1}{the probability of observing a methylated read when the underlying true status is methylated.}

\item{X}{the matrix of the read coverage for each CpG in each sample; a matrix of n rows and \code{p} columns}

\item{Z}{numeric vector of length p for the covariate; currently, the covariate is the percentage of Cell type A (considering that the samples are composed of two cell types A and B); (Added on Feb 2018), Z can be a matrix; we allow for more than one covariates}

\item{binom.link}{the link  function used for simulation}
}
\value{
The function returns a list of following objects

\code{S} the true methylation counts; a numeric matrix of \code{n} rows and \code{p} columns

\code{Y} the observed methylation counts; a numeric matrix of \code{n} rows and \code{p} columns

\code{theta} the methylation parameter (after the logit transformation); a numeric matrix of \code{n} rows and \code{p} columns
}
\description{
Simulate Bisulfite sequencing data from a Generalized Additive Model with functional parameters varying with the genomic position. Both the true methylated counts and observed methylated counts are generated, given the error/conversion rate parameters \code{p0} and \code{p1}.
}
\examples{
#------------------------------------------------------------#
# Generate functional parameter theta.0, position based from the
# real data set "Data_HHM" in the package SMSC
#------------------------------------------------------------#
library(SMSC)
data("Data_HHM")
y <- Data_HHM
fit1 <- SMSC(y$Ccount, y$CT, y$position, method = "KNN2")
par(mfrow = c(1, 1))
plotSMSC(y$Ccount / y$CT, y$origin, y$position, fit1) # The methylation levels are stored in fit$pi
plot(y$position, fit1$pi, type = "l", lwd = 3)
# #retrieve the region between (590kb - 700kb)
abline(v = 590000)
abline(v = 700000)
window.id <- which(y$position > 590000 & y$position < 700000)
# smooth.spline for the logit scale
my.exp.y <- log(fit1$pi[window.id] / (1 - fit1$pi[window.id]))
my.nknots <- 5
plot(y$position[window.id], my.exp.y,
  ylim = c(-4, 8), main = "Region of interest",
  xlab = "Position", ylab = expression(paste("Logit of methylation level ", theta[0], sep = " "))
)
ff <- smooth.spline(y$position[window.id], my.exp.y, nknots = my.nknots)
lines(ff, col = my.nknots, lty = 6)
# transform back to the scale (0, 1)
my.fit.pi <- exp(ff$y) / (1 + exp(ff$y))

plot(y$position[window.id], fit1$pi[window.id],
  ylim = c(-0.2, 1.2), main = "Region of interest",
  xlab = "Position", ylab = expression(paste("A smooth estimate of ", pi[0], sep = " "))
)
lines(y$position[window.id], my.fit.pi, col = 2, type = "b", lty = 3)
#---------------------------------------------------------------------
# Note: the estimation of the smooth curve pi0[t] is obtained from function
# "smooth.spline" -- fixing the degree of freedom (i.e. fixing lambda) -- selected by eyes
my.t <- y$position[window.id] # Position
theta.0 <- predict(ff, my.t)$y # theta.0  There are 90 CpGs in this region
pi.0 <- exp(theta.0) / (1 + exp(theta.0))
#---------------------------------------------------#
# Sample size and random effect
#---------------------------------------------------#
my.n <- 8 # sample size
sigma.ee <- 1 # variance of random effect
#-----------------------------------#
# Generate function beta(t)-- Linear
#-----------------------------------#
my.coef <- 10
my.beta <- (my.t - min(my.t)) / (max(my.t) - min(my.t)) * my.coef
#-----------------------------------------------------------------#
# Generate read covarage matrix my.X and Z the percentage of type A
#-----------------------------------------------------------------#
# Generate X (Read Covarage)---using the bootstrap
my.X <- matrix(NA, nrow = my.n, ncol = length(pi.0))
for (i in 1:my.n) {
  my.X[i, ] <- sample(y$CT, size = length(pi.0), replace = T)
}
my.Z <- rbeta(my.n, shape1 = 2, shape2 = 2)
my.data <- BSMethGammSim(
  n = my.n, posit = my.t, theta.0 = theta.0, beta = my.beta, sigma.ee = sigma.ee,
  X = my.X, Z = my.Z
)
my.data <- BSMethGammSim(
  n = my.n, posit = my.t, theta.0 = theta.0, beta = my.beta, sigma.ee = sigma.ee,
  X = my.X, Z = my.Z, random.eff = F
)
}
\author{
Kaiqiong Zhao
}
